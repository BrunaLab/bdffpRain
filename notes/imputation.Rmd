---
title: "Learning Imputation"
author: "Eric R. Scott"
date: "2020-07-21"
output: 
  html_notebook: 
    highlight: kate
    theme: yeti
    toc: yes
    toc_float: yes
    number_sections: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(here)
library(conflicted)
library(tsibble)
library(imputeTestbench)
library(lubridate)
library(janitor)
library(naniar)
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")
```

*Last compiled: `r Sys.Date()`*

# Purpose

Explore options for imputation of missing values

# Load & Wrangle Data

```{r data, echo=TRUE}
bdffp <- read_csv(here("data_cleaned", "daily_precip.csv"))
```

I think I want this wide with just date, and site columns with precip values.  I'll remove ALL accumulations for this test.

```{r}
bdffp_wide <-
  bdffp %>% 
  mutate(precip = ifelse(is.na(lag(precip)), NA, precip)) %>% 
  as_tsibble(key = site, index = date) %>% 
  fill_gaps() %>% 
  select(date, site, precip) %>% 
  as_tibble() %>% 
  pivot_wider(names_from = site, values_from = precip) %>% 
  clean_names() 

bdffp_test <-
  bdffp_wide %>% 
  #create "clusters"
  rowwise() %>% 
  mutate(colosso_clust = mean(c(colosso, cabo_frio, florestal), na.rm = TRUE),
         km_clust = mean(c(km37, km41), na.rm = TRUE)) %>% 
  mutate(across(ends_with("_clust"), ~ifelse(is.nan(.x), NA, .x))) %>% 
  #only include 4 most-used sites
  select(date, dimona, porto_alegre, km_clust, colosso_clust) %>% 
  filter(date < ymd("2010-11-26"))

vis_miss(bdffp_test)
```



```{r}
manaus <- read_csv(here("data_cleaned", "manaus_weather.csv"))
manaus_ts <-
  manaus %>%
  filter(between(date, min(bdffp_test$date), max(bdffp_test$date))) %>% 
  select(date, precip) %>%
  as_tsibble(index = date) %>% 
  fill_gaps() %>% 
  as.ts()
```

# Testing with imputeTestBench

This package is built for testing univariate timeseries imputation, but I can supply my own functions, I think, and it will work as long as they take a time series object and return a time series object.

NOTE: this stack exchange thread says that `mtdsi` is only applicable for normally distributed data: https://stats.stackexchange.com/questions/261271/imputation-methods-for-time-series-data/290563

log transformation might help (`log = TRUE`)

```{r eval=FALSE}
manaus_ts %>% as_tsibble() %>% filter(between(index, first(index), nth(index, 730))) %>% as.ts() -> test
out <-
  imputeTestbench::impute_errors(
    test,
    smps = "mar",
    blck = 7,
    blckper = FALSE,
    methods = c("na_mean",
                # "interp_mice",
                # "interp_mtsdi", #waaaay too slow
                ),
    methodPath = here("R", "interpolation_tests.R")
  )
out
plot_errors(out)
```

Wow, `mice` does a terrible job!  `mtsdi` is waaay too slow!

# With Amelia II

```{r}
library(Amelia)
```

Make a data frame for testing.  For now I'll only use precip values so I can switch between wide and long formats more easily.

```{r}
full_wide <-
  left_join(bdffp_test, manaus, by = "date") %>%
  mutate(year = year(date), doy = yday(date)) %>%
  select(year, doy, everything()) %>%
  select(- temp_max, -temp_min, -sun_time)

slice_wide <- full_wide[3000:4000,] %>% as.data.frame()
slice_wide <- slice_wide %>% rename(manaus = precip) %>% select(year, doy, date:manaus)
```

```{r}
imp_simple <- amelia(slice_wide, idvars = c("date", "doy", "year"))
plot(imp_simple)
```

```{r}
imp_tsdoy <-
  amelia(
    slice_wide,
    p2s = 1,
    m = 10,
    ts = "doy",
    cs = "year",
    intercs = TRUE,
    polytime = 3,
    logs = c("dimona", "porto_alegre", "km_clust", "colosso_clust", "manaus"),
    idvars = c("date"),
    empri = .01*nrow(slice_wide) #ridge penalty because of high degree of missingness
  )
imp_tsdoy
tscsPlot(imp_tsdoy, cs = "1996", var = "km_clust")
```

```{r}
slice_long <- 
  slice_wide %>% 
  pivot_longer(dimona:manaus, names_to = "site", values_to = "precip") %>% 
  arrange(site, date) %>% 
  mutate(date_num = as.numeric(date)) %>% as.data.frame()

imp_tsdate <-
  amelia(
    slice_long,
    m = 10,
    p2s = 1,
    ts = "date",
    cs = "site",
    intercs = TRUE,
    polytime = 3,
    logs = c("precip"),
    idvars = c("year", "doy", "date_num"),
    empri = .01*nrow(slice_long) #ridge penalty because of high degree of missingness
  )
imp_tsdate
```
So I've imputed this dataset two ways:
1. in `imp_tsdoy` using day of year as the time series variable and year as a cross-section with each site as a different variable.
2. in `imp_tsdate` using date as the time series variable and site as a cross-section with only one variableâ€”precip.

I want to look at their performance to see if one is better

```{r}
imp_tsdoy
```
The chain lengths for the first method are fairly different, potentially indicating a problem.

```{r}
imp_tsdate
```

```{r}
tscsPlot(imp_tsdoy, cs ="1996", var = "dimona", ylim = c(0,100))
```

```{r}
as.numeric(ymd("1996-12-31"))
tscsPlot(imp_tsdate, cs = "dimona", var = "precip", xlim = c(9496, 9861), ylim = c(0,100))
```

Confidence intervals smaller with date method, but values look weird.  Zeroes seem much less likely for this method.

Let's try adding more variables

```{r}
slice_wide2 <-
  full_wide %>% 
  rename(manaus = precip) %>% 
  filter(between(date, min(slice_wide$date), max(slice_wide$date))) %>% 
  as.data.frame()

# hist(slice_wide2$wind_speed)

imp_ts2 <-
  amelia(
    slice_wide2,
    m = 10,
    p2s = 1,
    ts = "doy",
    cs = "year",
    intercs = TRUE,
    polytime = 3,
    logs = c("dimona", "porto_alegre", "km_clust", "colosso_clust", "manaus", "piche_evap", "wind_speed"),
    idvars = c("date"),
    empri = .005*nrow(slice_wide) #ridge penalty because of high degree of missingness
  )
```
```{r}
imp_ts2
```

```{r}
tscsPlot(imp_tsdoy, cs ="1996", var = "dimona", ylim = c(0,100))
tscsPlot(imp_ts2, cs ="1996", var = "dimona", ylim = c(0,100))

```
smaller CIs

Let's try adding leads and lags of precip

```{r}
imp_ts3 <-
  amelia(
    slice_wide2,
    m = 10,
    p2s = 1,
    ts = "doy",
    cs = "year",
    intercs = TRUE,
    polytime = 3,
    leads = c("dimona", "porto_alegre", "km_clust", "colosso_clust", "manaus"),
    lags = c("dimona", "porto_alegre", "km_clust", "colosso_clust", "manaus"),
    logs = c("dimona", "porto_alegre", "km_clust", "colosso_clust", "manaus", "piche_evap", "wind_speed"),
    idvars = c("date"),
    empri = .005*nrow(slice_wide) #ridge penalty because of high degree of missingness
  )
```
```{r}
tscsPlot(imp_tsdoy, cs ="1996", var = "km_clust", ylim = c(0,150))
tscsPlot(imp_ts2, cs ="1996", var = "km_clust", ylim = c(0,150))
tscsPlot(imp_ts3, cs ="1996", var = "km_clust", ylim = c(0,150))
```

```{r}
overimpute(imp_tsdoy, var = "km_clust")
overimpute(imp_ts2, var = "km_clust")
overimpute(imp_ts3, var = "km_clust")
plot(imp_ts3)
```
Color is row-wise missingness.  Ideal would be on line, that means if you pull out a precip value at, say 100 mm, then it would imput that value as 100mm perfectly every time.

```{r}
disperse(imp_ts3, dims = 1, m = 10)
```
Converges fine.
